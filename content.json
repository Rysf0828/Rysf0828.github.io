{"meta":{"title":"胡宇义|个人博客","subtitle":"胡宇义|个人博客","description":"胡宇义|个人博客","author":"胡宇义","url":"https://Rysf0828.github.io","root":"/"},"pages":[{"title":"Tags","date":"2019-12-12T06:19:24.000Z","updated":"2019-12-12T07:32:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://rysf0828.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-12-12T06:19:24.000Z","updated":"2019-12-12T07:32:18.000Z","comments":true,"path":"categories/index.html","permalink":"https://rysf0828.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Typora基本语法","slug":"Typora-grammar","date":"2019-12-17T02:15:01.875Z","updated":"2019-12-17T07:35:17.778Z","comments":true,"path":"2019/12/17/Typora-grammar/","link":"","permalink":"https://rysf0828.github.io/2019/12/17/Typora-grammar/","excerpt":"","text":"本文转载自Mrakdown基本语法，主要是记录Markdown基本语法的使用，另外也是本博客第一篇文章。 一级标题二级标题三级标题四级标题五级标题加粗 倾斜 倾斜加粗 删除 百度链接 这里是代码 1这里也是代码","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://rysf0828.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://rysf0828.github.io/tags/Typora/"}]},{"title":"java项目路径","slug":"Servlet-demo","date":"2019-12-17T02:15:01.872Z","updated":"2019-12-17T07:35:09.124Z","comments":true,"path":"2019/12/17/Servlet-demo/","link":"","permalink":"https://rysf0828.github.io/2019/12/17/Servlet-demo/","excerpt":"项目结构##本文通过一个最简单的servlet demo来介绍，采用的是maven进行管理： 1234567891011121314151617181920.├── pom.xml├── src ├── main │ ├── java │ │ └── com │ │ └── cnhachiman │ │ ├── filter │ │ └── servlet │ │ └── DemoServlet.java │ ├── resources │ │ └── com │ │ └── cnhachiman │ │ └── servlet │ │ └── demo.properties │ └── webapp #这里在pom中设置为项目的sourceDirectory │ └── WEB-INF │ └── web.xml └── test └── java 项目打包的maven插件： 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt; &lt;warName&gt;ServletDemo&lt;/warName&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;finalName&gt;ServletDemo&lt;/finalName&gt;&lt;/build&gt; war包结构将项目达成war包后的目录结构如下： 123456789101112.├── META-INF└── WEB-INF ├── lib #这里放的依赖的jar包 ├── web.xml └── classes └── com └── cnhachiman └── filter └── servlet ├── DemoServlet.class └── demo.properties 用maven构建项目时候resource目录就是默认的classpath，src路径下的文件在编译后会放到WEB-INF/classes路径下，也是classpath。两个文件夹内容打包过后都会放到classes下 下面是我的DemoServlet类，需要注意的是重写的service方法的入参是HttpServletRequest和HttpServletResponse","text":"项目结构##本文通过一个最简单的servlet demo来介绍，采用的是maven进行管理： 1234567891011121314151617181920.├── pom.xml├── src ├── main │ ├── java │ │ └── com │ │ └── cnhachiman │ │ ├── filter │ │ └── servlet │ │ └── DemoServlet.java │ ├── resources │ │ └── com │ │ └── cnhachiman │ │ └── servlet │ │ └── demo.properties │ └── webapp #这里在pom中设置为项目的sourceDirectory │ └── WEB-INF │ └── web.xml └── test └── java 项目打包的maven插件： 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt; &lt;warName&gt;ServletDemo&lt;/warName&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;finalName&gt;ServletDemo&lt;/finalName&gt;&lt;/build&gt; war包结构将项目达成war包后的目录结构如下： 123456789101112.├── META-INF└── WEB-INF ├── lib #这里放的依赖的jar包 ├── web.xml └── classes └── com └── cnhachiman └── filter └── servlet ├── DemoServlet.class └── demo.properties 用maven构建项目时候resource目录就是默认的classpath，src路径下的文件在编译后会放到WEB-INF/classes路径下，也是classpath。两个文件夹内容打包过后都会放到classes下 下面是我的DemoServlet类，需要注意的是重写的service方法的入参是HttpServletRequest和HttpServletResponse 另外最近看到getResourceAsStream(String path)这个方法，也在这里记录下： 在Springmvc源码里面有看到这样的代码 1234567891011121314// org.springframework.web.context.ContextLoader private static final String DEFAULT_STRATEGIES_PATH = &quot;ContextLoader.properties&quot;; private static final Properties defaultStrategies; static &#123; try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException(&quot;Could not load &apos;ContextLoader.properties&apos;: &quot; + ex.getMessage()); &#125; &#125; 点进去发现了这个方法： 12345678910111213141516public InputStream getInputStream() throws IOException &#123; InputStream is; if (this.clazz != null) &#123; is = this.clazz.getResourceAsStream(this.path); &#125; else if (this.classLoader != null) &#123; is = this.classLoader.getResourceAsStream(this.path); &#125; else &#123; is = ClassLoader.getSystemResourceAsStream(this.path); &#125; if (is == null) &#123; throw new FileNotFoundException(getDescription() + &quot; cannot be opened because it does not exist&quot;); &#125; return is;&#125; 这里容易发现上面代码实际执行方法是： 12345Properties props = new Properties();InputStream is;is = this.clazz.getResourceAsStream(&quot;ContextLoader.properties&quot;);props.load(is);defaultStrategies=props; 发现在resources\\org\\pringframework\\web\\context下存在ContextLoader.properties,其中设置了默认ApplicationContext: 1org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext 最后整理下getResourceAsStream的用法，以及ClassLoader.getSystemResourceAsStream()用法。 m.class.getResourceAsStream(String path) path 不以’/‘开头时默认是从此类所在的包下取资源 path以’/‘开头则是从ClassPath根下获取 m.class.getClassLoader().getResourceAsStream(String path)默认从classpath根下获取，path不能以’/‘开头 ClassLoader.getSystemResourceAsStream(String path)与m.class.getResourceAsStream(String path)的第二种方式一致，但是入参路径少了’/‘","categories":[{"name":"classpath","slug":"classpath","permalink":"https://rysf0828.github.io/categories/classpath/"}],"tags":[{"name":"classpath","slug":"classpath","permalink":"https://rysf0828.github.io/tags/classpath/"}]},{"title":"Hexo部署到阿里云","slug":"Hexo-deploy","date":"2019-12-17T02:15:01.869Z","updated":"2019-12-17T07:35:42.989Z","comments":true,"path":"2019/12/17/Hexo-deploy/","link":"","permalink":"https://rysf0828.github.io/2019/12/17/Hexo-deploy/","excerpt":"本文是在网上的资料和自己实践的情况下总结的，特此记录下来 服务器环境搭建安装Nginx使用yum安装nginx，yum命令使用详见：yum源配置 1yum install -y nginx nginx相关配置和命令nginx查看路径 1nginx -V yum安装nginx的默认路径： Nginx配置路径：/etc/nginx/ PID目录：/var/run/nginx.pid 错误日志：/var/log/nginx/error.log 访问日志：/var/log/nginx/access.log 默认站点目录：/usr/share/nginx/html nginx相关的验证和启动命令 启动：nginx 测试命令(可测试配置文件格式)：nginx -t 强制停止：nginx -s stop 关闭停止：nginx -s quit 修改nginx.conf之后，可以重载 nginx -s relaod nginx配置文件本文参考的是：Nginx综合介绍以及配置文件详解 安装Git1yum install git 检查安装信息:git --version","text":"本文是在网上的资料和自己实践的情况下总结的，特此记录下来 服务器环境搭建安装Nginx使用yum安装nginx，yum命令使用详见：yum源配置 1yum install -y nginx nginx相关配置和命令nginx查看路径 1nginx -V yum安装nginx的默认路径： Nginx配置路径：/etc/nginx/ PID目录：/var/run/nginx.pid 错误日志：/var/log/nginx/error.log 访问日志：/var/log/nginx/access.log 默认站点目录：/usr/share/nginx/html nginx相关的验证和启动命令 启动：nginx 测试命令(可测试配置文件格式)：nginx -t 强制停止：nginx -s stop 关闭停止：nginx -s quit 修改nginx.conf之后，可以重载 nginx -s relaod nginx配置文件本文参考的是：Nginx综合介绍以及配置文件详解 安装Git1yum install git 检查安装信息:git --version 创建Git用户并设置密码12345adduser git#设置git密码，需要root权限sudo passwd gitchmod 740 /etc/sudoersvim /etc/sudoers 找到以下内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 在下面添加一行，为git用户添加权限(这里其实不知道为什么这么做，留待后面了解下linux的这个文件啥作用) 1git ALL=(ALL) ALL 保存退出后修改回文件权限:chmod 400 /etc/sudoers git服务器打开RSA认证编辑文件:vim /etc/ssh/sshd_config 在sshd_config中开启以下几项： 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 配置ssh免密登录切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限 123456su gitmkdir ~/.sshvim ~/.ssh/authorized_keys#打开当前电脑登录用户文件夹下.ssh/id_rsa.pub文件,将公钥内容复制粘贴到服务器authorized_keyschmod 600 ~/.ssh/authorzied_keyschmod 700 ~/.ssh 使用ssh命令测试是否可以免密登录ssh git@serverip 创建Git仓库执行命令：sudo git init --bare hexo.git 使用–bare 参数，Git 就会创建一个裸仓库，裸仓库没有工作区，我们不会在裸仓库上进行操作，它只为共享而存在。 改变 hexo.git 目录的拥有者为git用户：sudo chown -R git:git hexo.git 配置钩子在 hexo.git/hooks 目录下新建一个 post-receive 文件，进入cd /home/git/hexo.git/hooks/，编辑这个文件vim post-receive 在 post-receive 文件中写入如下内容： 12#!/bin/bashgit --work-tree=/usr/share/nginx/blog --git-dir=/home/git/hexo.git checkout -f 设置这个文件的可执行权限：sudo chmod +x post-receive usr/share/nginx/blog需要换成自己的部署目录，本文使用的yum命令安装的nginx，默认的html文件夹是/usr/share/nginx/html，我的博客改成了/usr/share/nginx/blog。这样每次hexo生成html文件就会自动提交到服务器上，最后到nginx文件夹下 Git用户禁用shell登录 出于安全考虑，git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成,这里参考的是：廖雪峰的Git教程,，但是奇怪的是之后使用ssh登录之后打印了: 12fatal: Interactive git shell is not enabled.hint: ~/git-shell-commands should exist and have read and execute access. 看字面意思是少了git-shell-commands，最后还是在评论里面解决了问题,代码如下: 1234567891011$ su git$ chsh -s /usr/bin/git-shell$ mkdir $HOME/git-shell-commands$ cat &gt;$HOME/git-shell-commands/no-interactive-login &lt;&lt;\\EOFprintf &apos;%s\\n&apos; &quot;Hi $USER! You&apos;ve successfully authenticated, but I do not&quot;printf &apos;%s\\n&apos; &quot;provide interactive shell access.&quot;exit 128EOF$ chmod +x $HOME/git-shell-commands/no-interactive-login 需要注意的是这里修改之后文件:git:x:1000:1000::/home/git:/usr/bin/git-shell，前面是home/git,因此myBlog/_config.yml配置文件： 12345deploy: type: git repo: github: git@47.103.73.117:hexo.git branch: master 参考资料Hexo部署在阿里云服务器上:https://www.jianshu.com/p/e1ccd49b4e5d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://rysf0828.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://rysf0828.github.io/tags/Hexo/"}]}]}